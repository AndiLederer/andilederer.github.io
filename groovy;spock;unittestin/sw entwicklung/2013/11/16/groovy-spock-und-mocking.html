<p><img src="http://farm5.staticflickr.com/4010/4587872629_df3e226079_d.jpg" /><br />Ich bin jetzt schon seit Jahren Java Entwickler. Dabei startete ich im Java EE Bereich. Von da ging es ziemlich schnell zum Springframework, was im Vergleich zum Standard einen wirklich sehr leichtgewichtigen Ansatz verfolgt. Trotzdem kann ich mit Sicherheit sagen, ich habe schon mehr XML-Konfigurationsdateien geschrieben als mir lieb ist.</p>
<p>Mit <a href="http://rubyonrails.org/">Ruby on Rails</a>, <a href="http://grails.org/">Grails</a> und teilweise dem <a href="http://spring.io/">Springframework</a> ist dazu eine eindeutige Gegenbewegung, mit dem Motto “<a href="http://de.wikipedia.org/wiki/Konvention_vor_Konfiguration">Konvention vor Konfiguration</a>”, entstanden. Für mich begann damit die Zeit, in der ich mit verschiedenen <a href="http://de.wikipedia.org/wiki/Dynamische_Programmiersprache">dynamischen Programmiersprachen</a> und ihren Frameworks experimentierte. In meinem beruflichen Umfeld konnte ich dieses Konzept nicht wirklich zum Einsatz bringen. Die bereits bestehenden Anwendungen wirken dabei wie ein Anker der, ab einer gewissen Anzahl von Anwendungen, nicht mehr gehoben werden kann. </p>
<h1>Begeisterung für dynamische Programmiersprachen</h1>
<p>Die Zeit mit den unterschiedlichen Programmiersprachen war jedoch nicht umsonst. Viele Verbesserungen, in meiner Art, Programme zu schreiben wurden dadurch möglich. Einige der dort vorhanden Konzepte konnte ich auch in die tägliche Arbeit integrieren. Auch die Begeisterung für dynamische Programmiersprachen ist geblieben.</p>
<h1>Groovy und Spock</h1>
<p align="left">Vor kurzen wurde ich durch einen <a href="http://hanselminutes.com/392/groovy-on-grails-with-netflixs-clay-mccoy">Podcast</a> auf das <a href="https://code.google.com/p/spock/">Spezifikationsframewok “Spock”</a> aufmerksam, welches mit <a href="http://groovy.codehaus.org/">Groovy</a> auf der <a href="http://de.wikipedia.org/wiki/Java_Virtual_Machine">JVM</a> ausgeführt werden kann. <br />Mit diesem Test-Framework können Code-Spezifikationen erstellt werden. Spock bedient sich dabei einer eigenen <a href="http://de.wikipedia.org/wiki/Dom%C3%A4nenspezifische_Sprache">Domain Specific Language</a>(DSL), die eine sehr übersichtliche Spezifizierung von erwarteten Verhalten ermöglicht. Vor allem möchte ich damit Spezifikationen für Java-Klassen erstellen können. Als Test habe ich einige Spezifikationen gegen die <a href="http://www.joda.org/joda-time/">JodaTime</a>-Library erstellt. Dabei bin ich den Anweisungen auf der <a href="https://code.google.com/p/spock/wiki/GettingStarted">GettingStarted-Seite</a> gefolgt.</p>
<p><font face="Helvetica"><strong>ACHTUNG: Groovy 1.8.6 muss installiert sein. Keine andere Version von Groovy wird unterstützt.</strong></font></p>
<p>Es findet sich leider keine Anleitung für die Verwendung von Maven 3, welches beim aktuellen NetBeans-IDE mit installiert ist. Nach der Entfernung des Spock-Plugins und der Umbenennung der Testklasse von “NameSpock.groovy” auf “NameTest.groovy” wurde der Testfall richtig erkannt und wie erwartet ausgeführt.</p>
<h1></h1>
<h1>Spock Blocks</h1>
<p>Das Hauptkonzept von Spock ist es, die einzelnen zu spezifizierenden Funktionen in Blöcke zu gruppieren. Dieses können miteinander kombiniert werden, auch können mehrere Codezeilen zu einem Block gehören.</p>
<p>Hier ein Übersicht aus der Spock-Wiki Seite.</p>
<p><img src="http://spock.googlecode.com/svn/wiki/Blocks2Phases.png" /></p>
<p><a href="https://code.google.com/p/spock/wiki/SpockBasics">Quelle SpockBasics</a></p>
<p>Das Dreamteam der Blockpaare ist:</p>
<blockquote> <p><font face="Helvetica">when: // beinhält einen Methodenaufruf<br />then: // hier wird ein erwarteter Zustand des Objektes überprüft</font></p></blockquote>
<p><em>Soll auf mehrere Werte geprüft werden, erfolgt dass mit einer </em></p>
<blockquote> <p><font face="Helvetica">expect: // Methodenaufruf mit Ergebnisvergleich<br />where: // Angeabe von Parametern</font></p></blockquote>
<p><em>Kombination.</em></p>
<h1>Mocking</h1>
<p>Das Spock-Framework verfügt auch über ein eigenes Framework für die Erstellung von <a href="https://code.google.com/p/spock/wiki/Interactions">Mocks</a>. Die dort gebotenen Funktionen habe ich noch nicht ausprobiert, die Syntax ist jedoch einfach und sollte für die meisten Fälle ausreichend sein. Ein detailliertes Beispiel habe ich auf <a href="http://kousenit.wordpress.com/2011/08/20/i-think-i-get-spock-mocks-now/">dieser Seite gefunden</a>.</p>
<h1>RSpec vs Spock</h1>
<p>Grundsätzlich fühlt sich Groovy von der Syntax ähnlicher zu Java an als Ruby. Ruby verfügt aber ebenfalls über ein sehr gutes Tool zur Spezifizierung “<a href="http://rspec.info/">RSpec</a>”. Mittels JRuby lässt sich dieses auch nutzen. Schon vor einigen Jahren hat es mehrere Versuche gegeben, Werkzeuge aus der Ruby-Welt für Java nutzbar zu machen:</p>
<ul> <li><a href="http://patshaughnessy.net/2009/6/25/taming-the-beast-using-jruby-and-rspec-to-test-a-j2ee-application">RSpec und Spring.</a>  <li><a href="http://asymmetrical-view.com/2010/02/19/maven-rspec.html">Mavenintegration und Beispiel</a></li> <p>In der nächsten Zeit werde ich sicher einige Spezifikationen mit Spock erstellen, sollte sich dadurch eine Erleichterung beim testen ergeben werde ich wahrscheinlich bei diesem Framework bleiben.</p> <p>Weitere Links:</p> <ul> <li><a href="http://fbflex.wordpress.com/2013/09/18/testing-spring-boot-applications-with-spock/">Spring Testing</a></li> <li><a href="http://jnario.org/">Jnario.org Executable Specifications for Java</a></li></ul>
</li></ul>
