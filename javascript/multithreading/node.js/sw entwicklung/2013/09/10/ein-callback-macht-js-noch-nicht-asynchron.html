<p><strong></strong> &lt;p&gt;<img src="http://farm2.staticflickr.com/1422/818815240_501bc7117a_d.jpg" />&lt;/p&gt; &lt;p&gt;<br />Wird ein Ajax Request aufgerufen, läuft der Code wie gewohnt weiter. Kommt die Antwort, wird der Callback ausgeführt und es fühlt sich an, als würden mehrere Prozesse ablaufen. Doch handelt es sich hier um <a href="http://de.wikipedia.org/wiki/Multithreading" target="_blank">Multithreading</a> oder ist alles nur vorgegaukelt? Leider ist diese Parallelität nur vorgetäuscht. Javascript wird nur innerhalb eines Prozesses ausgeführt. Selbst in <a href="http://nodejs.org/" target="_blank">Node.js</a> gibt es nur einen Prozess.<br />Die besten Antworten habe ich im <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.setTimeout" target="_blank">Mozilla Developer Network</a> und bei <a href="http://howtonode.org/understanding-process-next-tick" target="_blank">HOTTO Node</a> gefunden.&lt;/p&gt; &lt;h1&gt;Wie funktioniert es trotzdem&lt;/h1&gt; &lt;p&gt;Durch die Funktion <em>setTimeout()</em> wird die Ausführung der übergebenen Funktion an das Ende der Ausführungskette gestellt. Die übergebene Methode wird erst ausgeführt, wenn die Zeitspanne abgelaufen ist und die synchronen Bearbeitung fertig ist. Das war es auch schon. Durch diesen einfache Trick wird eine Blockierung der Benutzeransicht verhindert.&lt;/p&gt; &lt;h1&gt;Weiter Möglichkeit innerhalb von Node.js&lt;/h1&gt; &lt;p&gt;Von Node.js wird die Funktion <em>process.nextTick(callback)</em> bereit gestellt.<br />Diese ist effektiver, da direkt der Eventstack von Node.js verwendet wird.<br />Die Bearbeitung des Callback wird erst nach Fertigstellung der aufrufenden Methode ausgeführt.&lt;/p&gt; &lt;h1&gt;THIS Kontextänderung&lt;/h1&gt; &lt;p&gt;In meiner Testumgebung habe ich nicht die Möglichkeit diese Eigenschaft zu prüfen. Laut anderer <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.setTimeout#The_.22this.22_problem" target="_blank">Beiträge</a> wechselt die Referenz von <em>this</em> auf <em>window</em>. &lt;/p&gt; &lt;h1&gt;Test mit Node.js&lt;/h1&gt; &lt;p&gt;Diese kleine Anwendung ist mein erster Versuch mit Node.js. Für mich ist es auf jeden Fall die einfachste Lösung ein paar Zeilen JavaScript aus zu führen.&lt;/p&gt;&lt;pre class="brush: js;"&gt;var foo = function(){<br />    console.log(‘foo’);<br />};<br />// Prüfen ob das Verhalten innerhalb einer Funktion gleich bleibt.<br />(function(){<br />    setTimeout(<br />        function(){<br />            console.log(‘SET Timeout 1’);<br />        },0);<br />    console.log(‘bar’);<br />    //Für eine längere Ausführungszeit<br />    for(var i=0; i&lt;5000000;i++){<br />        Math.random();<br />    }<br />})();<br />foo();<br />setTimeout(<br />    function(){<br />        console.log(‘SET Timeout 2’);<br />    },0);
&lt;/pre&gt;</p>
<p><strong>Ergebnis:<br /></strong>bar<br />foo<br />SET Timeout 1<br />SET Timeout 2</p>
<h1>Zusammenfassung</h1>
<p>JavaScript wird in einem Thread ausgeführt. Das sollte bei Browseranwendungen vollkommen ausreichen. Bei Anwendungen, wie sie in Node.js erstellt werden können, sollte man sich dazu sicher mehr Gedanken machen. Vor allem CPU intensive Aufgaben können hier Schwierigkeiten verursachen. Zumindest können mehrere Node.js Serveranwendungen <a href="http://stackoverflow.com/questions/4710420/scaling-node-js" target="_blank">miteinander verbunden</a> werden.</p>
